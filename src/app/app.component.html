<div class="text-center">
  <h1>Description</h1>
</div>

<div class="desc">
  <mat-accordion>
    <mat-expansion-panel>
      <mat-expansion-panel-header>
        <mat-panel-title>
          Mat Data Grid
        </mat-panel-title>
        <mat-panel-description>
          Service Side Infinite Scrolling
        </mat-panel-description>
      </mat-expansion-panel-header>
      <h3>How it Works</h3>
      <p> The grid will ask your application, via a datasource, for the rows in blocks. 
        Each block contains a subset of rows of the entire data set. 
        The following diagram is a high level overview. </p>
        <img class="desc-image" [src]="imageLink1" alt="server-side-infinite-scrolling">

      <p> When the grid scrolls to a position where there is no corresponding block of rows loaded,
        the model uses the provided datasource to get the rows for the requested block.
        In the diagram, the datasource is getting the rows from a database in a remote server. </p>

      <h4>Configurable page size</h4>
      <p> The grid will fetch # of records as per selection for show-list</p>
        <img class="desc-image" [src]="imageLink1" alt="server-side-infinite-scrolling">
    </mat-expansion-panel>
    <mat-expansion-panel>
      <mat-expansion-panel-header>
        <mat-panel-title>
          Mat Data Grid
        </mat-panel-title>
        <mat-panel-description>
          Service-Side Filtering and Sorting
        </mat-panel-description>
      </mat-expansion-panel-header>
      <h3>Sorting & Filtering</h3>
      <p> The grid cannot do sorting or filtering for you, as it does not have all of the data.
        Sorting or filtering must be done on the Server-side. For this reason, if the sort or filter changes,
        the grid will use the datasource to get the data again and provide the sort and filter state to you. </p>
      <h4>How Sorting Works </h4>
      <h5>Step 1 : </h5>
      <img class="desc-image" [src]="s1" alt="sorting step1">
      <h5>Step 2 : </h5>
      <img class="desc-image" [src]="s2" alt="sorting step2">
      <h5>Step 3 : </h5>
      <img class="desc-image" [src]="s3" alt="sorting step3">
      <h5>Step 4 : </h5>
      <img class="desc-image" [src]="s4" alt="sorting step4">
      <h5>Step 5 : </h5>
      <img class="desc-image" [src]="s5" alt="sorting step5">
      <h4>How filtering Works </h4>
      <h5>Step 1 : </h5>
      <img class="desc-image" [src]="f1" alt="filtering step1">
      <h5>Step 2 : </h5>
      <img class="desc-image" [src]="f2" alt="filtering step2">
     
    </mat-expansion-panel>
    <mat-expansion-panel>
      <mat-expansion-panel-header>
        <mat-panel-title>
          Mat Data Grid
        </mat-panel-title>
        <mat-panel-description>
          Browser Memory Management
        </mat-panel-description>
      </mat-expansion-panel-header>
      <h3>Block Cache</h3>
      <p> The grid keeps the blocks in a cache. You can set a limit to the number of blocks kept. 
        If you set a limit, then as you scroll down, previous blocks will be discarded and will be loaded again if the user scrolls back up. 
        The maximum blocks to keep in the cache is set using the <strong>maxBlocksInCache</strong> property.</p>
        <p>This feature comes in handy when you are dealing with huge amount of data and do not want your browser to become slow after multiple page srolling
      </p>
    </mat-expansion-panel>
  </mat-accordion>
</div>
<div class="text-center">
  <h1>Mat-Data-Grid</h1>
</div>
<mat-data-grid 
  [uri]='uri' 
  [col-defs]='colDefs' 
  [row-selection]='rowsSelections' 
  [max-block-in-cache]='maxBlockInCache'
>